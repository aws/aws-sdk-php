<?php

namespace Aws\CloudTrail;

use Aws\Common\Exception\InvalidArgumentException;
use Aws\S3\S3Client;
use Guzzle\Common\Collection;
use Guzzle\Iterator\FilterIterator;

/**
 * The Aws\CloudTrail\LogRecordIterator provides an easy way to iterate over log records from log files generated by
 * AWS CloudTrail. CloudTrail log files contain data about your AWS API calls and are stored in Amazon S3 at a
 * predictable path based on a bucket name, a key prefix, an account ID, a region, and date information. The files are
 * gzipped and contain structured data in JSON format. This class allows you to specify options, including a date range,
 * and emits each log record from any log files that match the provided options.
 *
 * @yields Collection A log record containing data about an AWS API call is yielded for each iteration on this object
 */
class LogRecordIterator implements \Iterator
{
    const DEFAULT_TRAIL_NAME = 'Default';
    const PREFIX_TEMPLATE = 'prefix/AWSLogs/account/CloudTrail/region/date/';
    const PREFIX_WILDCARD = '*';

    const TRAIL_NAME = 'trail_name';
    const KEY_PREFIX = 'key_prefix';
    const START_DATE = 'start_date';
    const END_DATE = 'end_date';
    const ACCOUNT_ID = 'account_id';
    const LOG_REGION = 'log_region';

    /**
     * @var S3Client The Amazon S3 client used to perform ListObjects and GetObject operations
     */
    private $s3Client;

    /**
     * @var string The name of the Amazon S3 bucket that contains the log files published by AWS CloudTrail
     */
    private $bucketName;

    /**
     * @var \Iterator The internal iterator that emits Amazon S3 objects representing the log files
     */
    private $objectIterator;

    /**
     * @var \Iterator The internal iterator that emits log records and works in tandem with the objectIterator
     */
    private $recordIterator;

    /**
     * Contructs a LogRecordIterator. This factory method is used if the name of the S3 bucket containing your logs is
     * not known. This factory method uses a CloudTrail client and the trail name (or "Default") to find the
     * information about the trail necessary for constructing the LogRecordIterator
     *
     * Options:
     *
     * - trail_name: The name of the trail that is generating our logs. If none is provided, then "Default" will be
     *               used, since that is the name of the trail created in the AWS Management Console.
     * - key_prefix: The S3 key prefix of your log files. This value will be overwritten when using the `fromTrail()`
     *               method. However, if you are using the contructor, then this value will be used.
     * - start_date: The timestamp of the beginning of date range of the log records you want to read. You can pass this
     *               in as a `DateTime` object, integer (unix timestamp), or a string compatible with `strtotime()`.
     * - end_date:   The timestamp of the end of date range of the log records you want to read. You can pass this in as
     *               a `DateTime` object, integer (unix timestamp), or a string compatible with `strtotime()`.
     * - account_id: This is your AWS account ID, which is the 12-digit number found on the *Account Identifiers*
     *               section of the *AWS Security Credentials* page. See https://console.aws.amazon.com/iam/home?#security_credential
     * - log_region: The region of the services of the log records you want to read.
     *
     * @param CloudTrailClient $cloudTrailClient
     * @param S3Client         $s3Client
     * @param array            $options
     *
     * @return LogRecordIterator
     * @throws \Aws\Common\Exception\InvalidArgumentException
     */
    public static function fromTrail(CloudTrailClient $cloudTrailClient, S3Client $s3Client, array $options = array())
    {
        $trailName = isset($options[self::TRAIL_NAME]) ? $options[self::TRAIL_NAME] : self::DEFAULT_TRAIL_NAME;
        $bucketName = null;

        try {
            $result = $cloudTrailClient->describeTrails(array(
                'trailNameList' => array($trailName),
            ));
            $bucketName = $result->getPath('trailList/0/S3BucketName');
            $options[self::KEY_PREFIX] = $result->getPath('trailList/0/S3KeyPrefix');
        } catch (CloudTrailException $e) {
            // There was an error describing the trails
        }

        // If the bucket name is still unknown, then throw an exception
        if (!$bucketName) {
            $prev = isset($e) ? $e : null;
            throw new InvalidArgumentException('The bucket name could not be determined from the trail.', 0, $prev);
        }

        return new self($s3Client, $bucketName, $options);
    }

    /**
     * @param S3Client $s3Client
     * @param string   $bucketName
     * @param array    $options
     */
    public function __construct(S3Client $s3Client, $bucketName, array $options = array())
    {
        $this->s3Client = $s3Client;
        $this->bucketName = $bucketName;
        $this->objectIterator = $this->buildObjectIterator($options);
        $this->recordIterator = new \ArrayIterator();
    }

    /**
     * @return Collection
     * @see http://docs.aws.amazon.com/awscloudtrail/latest/userguide/eventreference.html
     */
    public function current()
    {
        echo __METHOD__ . "\n";
        if ($this->recordIterator->valid()) {
            return new Collection($this->recordIterator->current());
        } else {
            return false;
        }
    }

    public function next()
    {
        echo __METHOD__ . "\n";
        $this->recordIterator->next();

        // If all the records have been exhausted, get more records from the next log file
        while (!$this->recordIterator->valid()) {
            $this->objectIterator->next();
            if ($this->objectIterator->valid()) {
                // Load log records from the next object
                $this->recordIterator = $this->buildRecordIteratorForCurrentObject();
            } else {
                // The objects iterator is exhausted as well, so stop trying
                break;
            }
        }
    }

    public function key()
    {
        echo __METHOD__ . "\n";
        if ($object = $this->objectIterator->current()) {
            return $object['Key'] . '.' . $this->recordIterator->key();
        } else {
            return null;
        }
    }

    public function valid()
    {
        echo __METHOD__ . "\n";
        return $this->recordIterator->valid();
    }

    public function rewind()
    {
        echo __METHOD__ . "\n";
        $this->objectIterator->rewind();
        $this->recordIterator = $this->buildRecordIteratorForCurrentObject();
    }

    /**
     * Constructs an S3 ListObjects iterator, optionally decorated with FilterIterators, based on the provided options
     *
     * @param array $options
     */
    private function buildObjectIterator(array $options)
    {
        // Extract and normalize the date values from the options
        $startDate = isset($options[self::START_DATE]) ? $this->normalizeDateValue($options[self::START_DATE]) : null;
        $endDate = isset($options[self::END_DATE]) ? $this->normalizeDateValue($options[self::END_DATE]) : null;

        // Determine the parts of the key prefix of the log files being read
        $keyPrefixParts = array(
            'prefix'  => isset($options[self::KEY_PREFIX]) ? $options[self::KEY_PREFIX] : null,
            'account' => isset($options[self::ACCOUNT_ID]) ? $options[self::ACCOUNT_ID] : self::PREFIX_WILDCARD,
            'region'  => isset($options[self::LOG_REGION]) ? $options[self::LOG_REGION] : self::PREFIX_WILDCARD,
            'date'    => $this->determineDateForPrefix($startDate, $endDate),
        );

        // Determine the longest key prefix that can be used to retrieve all of the relevant log files
        $candidatePrefix = ltrim(strtr(self::PREFIX_TEMPLATE, $keyPrefixParts), '/');
        $logKeyPrefix = $candidatePrefix;
        if (($index = strpos($candidatePrefix, self::PREFIX_WILDCARD)) !== false) {
            $logKeyPrefix = substr($candidatePrefix, 0, $index);
        }

        // Create an iterator that will emit all of the objects matching the key prefix
        $objectsIterator = $this->s3Client->getListObjectsIterator(array(
            'Bucket' => $this->bucketName,
            'Prefix' => $logKeyPrefix,
        ));

        // Apply regex and/or date filters to the objects iterator to emit only log files matching the options
        $objectsIterator = $this->applyRegexFilter($objectsIterator, $logKeyPrefix, $candidatePrefix);
        $objectsIterator = $this->applyDateFilter($objectsIterator, $startDate, $endDate);

        return $objectsIterator;
    }

    /**
     * Constructs an ArrayIterator containing the log records of the current log file yielded by the objects iterator
     *
     * @return \ArrayIterator
     */
    private function buildRecordIteratorForCurrentObject()
    {
        // Fetch and decode the log file content
        $records = array();
        if ($object = $this->objectIterator->current()) {
            // Create a command for getting the log file object
            $command = $this->s3Client->getCommand('GetObject', array(
                'Bucket' => $this->bucketName,
                'Key'    => $object['Key'],
            ));

            // Make sure gzip encoding header is sent and accepted in order to inflate response data
            $command->set('ResponseContentEncoding', 'x-gzip');
            $command->prepare()->addHeader('Accept-Encoding', 'gzip');

            // Get the JSON response data and extract the log records
            $data = $command->getResponse()->json();
            if (isset($data['Records'])) {
                $records = $data['Records'];
            }
        }

        return new \ArrayIterator($records);
    }

    /**
     * Normalizes a date value to a unix timestamp
     *
     * @param string|\DateTime|int $date
     *
     * @throws \InvalidArgumentException
     */
    private function normalizeDateValue($date)
    {
        // Normalize start date to a unix timestamp
        if (is_string($date)) {
            $date = strtotime($date);
        } elseif ($date instanceof \DateTime) {
            $date = $date->format('U');
        } elseif (!is_int($date)) {
            throw new \InvalidArgumentException('Date values must be a string, an int, or a DateTime object.');
        }

        return $date;
    }

    /**
     * Uses the provided date values to determine a date part of the prefix
     *
     * @throws \InvalidArgumentException
     */
    private function determineDateForPrefix($startDate, $endDate)
    {
        // Prepare the date value (year, month, and day)
        $dateParts = array_fill_keys(array('Y', 'm', 'd'), self::PREFIX_WILDCARD);
        if ($startDate && $endDate) {
            foreach ($dateParts as $key => &$value) {
                $candidateValue = date($key, $startDate);
                if ($candidateValue === date($key, $endDate)) {
                    $value = $candidateValue;
                } else {
                    break;
                }
            }
        }

        return join('/', $dateParts);
    }

    /**
     * Applies a regex iterator filter that limits the ListObjects result set based on the provided options
     *
     * @param \Traversable $objectsIterator
     * @param string       $logKeyPrefix
     * @param string       $candidatePrefix
     *
     * @return \Traversable
     */
    private function applyRegexFilter($objectsIterator, $logKeyPrefix, $candidatePrefix)
    {
        if ($logKeyPrefix !== $candidatePrefix) {
            $regex = rtrim($candidatePrefix, '/' . self::PREFIX_WILDCARD) . '/';
            $regex = strtr($regex, array(self::PREFIX_WILDCARD => '[^/]+'));
            if ($logKeyPrefix !== $regex) {
                $objectsIterator = new FilterIterator($objectsIterator, function ($object) use ($regex) {
                    return preg_match("#{$regex}#", $object['Key']);
                });
            }
        }

        return $objectsIterator;
    }

    /**
     * Applies an iterator filter to restrict the ListObjects result set to the specified date range
     *
     * @param \Traversable $objectsIterator
     *
     * @return \Traversable
     */
    private function applyDateFilter($objectsIterator, $startDate, $endDate)
    {
        if ($startDate || $endDate) {
            $objectsIterator = new FilterIterator($objectsIterator, function ($object) use ($startDate, $endDate) {
                if (preg_match('/[0-9]{8}T[0-9]{4}Z/', $object['Key'], $matches)) {
                    $date = strtotime($matches[0]);
                    if ((!$startDate || $date >= $startDate) && (!$endDate || $date <= $endDate)) {
                        return true;
                    }
                }
                return false;
            });
        }

        return $objectsIterator;
    }
}
